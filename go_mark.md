# go知识点

1. 声明变量为啥go是放在变量后面，c++放前面？

   Golang中跟C++不一样的地方包括严格区分int,int16,int32和int64，同样区分float类型

   Golang是不支持隐形转换的

   Golang把变量类型写在变量之后，有利于代码的可读性，如：

   ```c
   ## 函数指针作为参数传入其中也变成一个函数指针
   double (*funcPtr)(double a, void(*funcPtr2)(int b, double c));
   ```

   ```go
   // go的实现可读性很强
   var v1 func(a float32, funcA func(b int, c double)) double
   ```

2. map的表为啥做成无序遍历？

   遍历map时，并不是固定从0号bucket开始遍历，每次都是从一个随机值序号的bucket开始遍历，并且是从这个bucket的一个随机序号的cell开始遍历，理由是当map扩容后，会发生key的搬迁，导致位置发生变更，这样，遍历map的结果是不可能按原来的顺序输出的.

3. map是如何扩容的？

   达到扩容的条件：

   * 装载因子超过阈值，6.5
   * overflow的bucket数量过多

4. go为啥不实现class类

5. go slice的底层实现

6. slice是指针传递还是引用传递

7. 关于接口和类：

   * 一个类只需要实现接口要求的所有函数，我们就说这个类实现了该接口
   * 实现类的时候，只需要关心自己应该提供哪些方法，不用再纠结接口需要拆的多细才合理
   * 接口由使用方按自身需求来定义，使用方无需关心是否有其他模块定义过类似的接口

8. 使用空结构体 struct{} 可以节省内存，一般作为占位符使用，表明这里并不需要一个值

   ```go
   fmt.Println(unsafe.Sizeof(struct{}{})) // 0
   ```

9. init() 函数是Go程序初始化的一部分。Go程序初始化先于main函数，由runtime的初始化每个导入的包，初始化顺序不是按照从上到下的导入顺序，而是按照解析的依赖关系，没有依赖的包最先初始化

10. go语言的局部变量是分配在栈上还是堆上的？

    由编译器决定，在go语言编译器会自动决定把一个变量是放在栈还是放在堆上，编译器会做逃逸分析，当发生变量的作用域没有超出函数范围，就可以在栈上，反之则必须分配在堆上

    ```go
    func foo() *int {
    	v := 11
    	return &v
    }
    
    func main() {
    	m := foo()
    	println(*m) // 11
    }
    ```

    `foo()` 函数中，如果 v 分配在栈上，foo 函数返回时，`&v` 就不存在了，但是这段函数是能够正常运行的。Go 编译器发现 v 的引用脱离了 foo 的作用域，会将其分配在堆上。因此，main 函数中仍能够正常访问该值。

11.  go返回局部变量的指针是否是安全的？

    这在 Go 中是安全的，Go 编译器将会对每个局部变量进行逃逸分析。如果发现局部变量的作用域超出该函数，则不会将内存分配在栈上，而是分配在堆上。

12. Go语言的gc的工作原理

    最常见的垃圾回收算法有标记清除法和引用计数法，go语言采用的标记清除法。并在此基础上使用了三色标记法和写屏障的技术，提高了效率。

    标记清除收集器是跟踪式垃圾收集器，其执行过程可以分成标记和清除两个阶段：

    标记阶段——从根对象出发查找并标记堆中所有存货的对象

    清除阶段——遍历堆中的全部对象，回收未被标记的垃圾对象并将回收的内存加入空闲链表

    标记清除算法的一个大大问题就是标记期间，需要stop the world，标记结束之后，用户才能继续执行业务逻辑。为了能够异步执行，减少stw时间，go语言采用了三色标记法、

    三色标记法程序中将对象分成白色，黑色和灰色三类：

    * 白色：不确定对象
    * 灰色：存货对象，子对象待处理
    * 黑色：存货对象

    标记开始时，将所有对象加入白色集合中（这一步需stw）。首先将跟对象标记为灰色，加入灰色集合，垃圾收集器取出一个灰色对象，将其标记为黑色，并将其指向的对象标记为灰色，加入灰色集合中。重复这个过程，知道灰色集合为空，标记阶段结束。那么白色对象既为可清理的对象，而黑色对象均为根可达的对象，不能被清理。

    三色标记法因为事多了一个白色状态来存放不确定对象，所以后续的标记阶段可以并发的执行。当然并发的代价可能会造成一些遗漏，因为早先被标记的黑色对象可能目前已经是不可达了。所以三色标记法是假阴性的算法。

    三色标记法并发执行仍存在一个问题，即在 GC 过程中，对象指针发生了改变。比如下面的例子：

    ```go
    A (黑) -> B (灰) -> C (白) -> D (白)
    ```

    正常情况下，D 对象最终会被标记为黑色，不应被回收。但在标记和用户程序并发执行过程中，用户程序删除了 C 对 D 的引用，而 A 获得了 D 的引用。标记继续进行，D 就没有机会被标记为黑色了（A 已经处理过，这一轮不会再被处理）。

    ```go
    A (黑) -> B (灰) -> C (白) 
      ↓
     D (白)
    ```

    为了解决这个问题，Go 使用了内存屏障技术，它是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码，类似于一个钩子。垃圾收集器使用了写屏障（Write Barrier）技术，**当对象新增或更新时，会将其着色为灰色**。这样即使与用户程序并发执行，对象的引用发生改变时，垃圾收集器也能正确处理了。

    一次完整的 GC 分为四个阶段：

    - 1）标记准备(Mark Setup，需 STW)，打开写屏障(Write Barrier)

    - 2）使用三色标记法标记（Marking, 并发）

    - 3）标记结束(Mark Termination，需 STW)，关闭写屏障。

    - 4）清理(Sweeping, 并发)

13.  当且仅当动态值和动态类型都为 nil 时，接口类型值才为 nil

14. go 中不同类型是不能比较的，而数组长度是数组类型的一部分，所以 […]int{1} 和 [2]int{1} 是两种不同的类型，不能比较；片是不能比较的

    ```go
    func main() {
        fmt.Println([...]int{1} == [2]int{1})
        fmt.Println([]int{1} == []int{1})
    }
    ```

15. for..range...循环次数在循环开始前就已经确定，循环内改变切片的长度，不影响循环次数

16. for...range..使用短变量声明(:=)的形式迭代变量，需要注意的是，变量 i、v 在每次循环体中都会被重用，而不是重新声明。

17. （数组）range 表达式是副本参与循环。被循环的数永远都是副本参与，对其的改动不影响其变动

18. 多重赋值分为两个步骤，有先后顺序：

    * 计算等号左边的索引表达式和取值表达式，接着结算等号右边的表达式

    * 第二步再进行赋值

19. select 会循环检测条件，如果有满足则执行并退出，否则一直循环检测。（满足则退出！）

20. 常量不同于变量的在运行期分配内存，常量通常会被编译器在预处理阶段直接展开，作为指令数据使用，所以常量无法寻址。

21. 无缓冲的channel是同步的，而有缓冲的channel是非同步的。

22. cap() 函数适用于数组、数组指针、slice 和 channel，不适用于 map，可以使用 len() 返回 map 的元素个数。

23. rune 是 int32 的别名一样，byte 是 uint8 的别名，别名类型无序转换，可直接转换。




 