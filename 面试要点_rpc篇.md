# RPC，网络相关

#### 1. IP的包头格式？HTTP的包头格式？TCP的包头格式？UDP的包头格式？

![1611581548170](C:\Users\Jrue\AppData\Roaming\Typora\typora-user-images\1611581548170.png)

URG(紧急位)：设置为1时，首部中的紧急指针有效；数据不经过缓冲区直接交付上层进程处理

PSH(推位)：设置为1时，要求把数据尽快的交给应用层，不做处理。交付仍然是从缓冲区进行交付的

#### 2. HTTP的状态码有哪些？

答：
HTTP状态码：

1. 1**： 信息。服务器收到请求，需要请求者继续执行请求

2. 2**：成功。操作被成功的接收并处理

3. 3**：重定向。需要进一步操作以完成请求

4. 4**：客户端错误。请求包含语法错误或者无法完成请求

5. 5**：服务端错误。服务器在处理请求过程中发生错误


#### 3. 什么是粘包？怎么处理粘包？

答：粘包产生的原因：

1. 发送端使用了Nagle算法，TCP包头很大，当发送的数据包很小的时候，数据占比很小，等到数据积攒到一定量后再发送数据
2. 接收端缓冲区太小，数据量较大，应用层处理能力不及时，导致多个包接收
3. TCP连接复用
4. 发送端数据包过大，数据超过缓冲区大小，则数据被分割发送
5. 流量控制和拥塞控制都有可能造成粘包

处理粘包问题：

1. 尾部标记序列：通过特殊标识符表示数据的边界
2. 头部标记：在tcp报文头部加上表示数据长度的字段值（放在选项中）

这里讲下Negal算法规则：

1. 如果包长度达到MSS长度，则允许发送
2. 如果包含FIN，则允许发送
3. 如果设置TCP_NODELAY，则允许发送
4. 未设置TCP_CORK选项时，若所有发出去的小数据包均被确认，则允许发送
5. 上述条件都未满足的时候，但发生了超时，则立即发送

#### 4. 怎么保证消息的一致性，可靠性和幂等性？

答：保证消息的这一系列属性，需要在发送端和接收端都做好调整，并且使用消息队列来解决以上问题：

1. 发送端： 
   1. 生产者发送消息先把消息持久化到redis中，然后监听消息是否发送成功，发送成功则删除redis的数据；此时为了保证数据的可靠性，需要起一个定时任务，间接的判断是否消息发送成功并接收到ACK，否则则从redis取出数据重传发送，重传收到了ACK后，定时任务关闭，并从redis删除数据
   2. 为了保证接收端能处理判断重复接收的数据，则需要在接收端生成唯一的消息ID接收端判断
2. 接收端：
   1. 消费者收到数据后，处理数据的同时要将消息ID保存到redis中，每次收到的消息要对比redis中保存的消息ID是否存在，存在则不处理此消息



#### 5. 什么是三次握手？三次握手的步骤有哪些？

#### 6. 为什么要三次握手？

#### 7. 怎么优化三次握手，有什么优化策略？

#### 8. 什么是四次挥手？四次挥手的步骤有哪些？

#### 9. 为什么要四次挥手？

#### 10. 怎么优化四次挥手，有什么优化策略？

#### 11. 网络拥塞控制的方式有哪些？

#### 12 TCP跟UDP有什么不同？

答：不同点：

1. 连接方式：TCP是面向连接的传输层的协议，传输数据要先建立连接；UDP可需要在建立连接的情况下传输数据

2. 服务对象：TCP是一对一对端的服务；UDP可支持一对一，一对多，多对多的通信服务

3. 可靠性：TCP是可靠交付数据；UDP是尽最大努力但不保证可靠的交付数据

4. TCP拥有诸如拥塞控制，流量控制等功能

5. 首部开销：TCP首部较大，不包括选项字段的情况下使用了20个字节；UDP只有固定的8个字节

6. 传输方式：TCP字节流的流式传输，没有数据边界；UDP是包传输，存在边界，可能丢包和乱序

7. 分片方式不同：TCP数据大小超过mss大小，则会在传输层进行分片，丢包只需要重传丢失的包；

   UDP数据大小超过MTU大小，则在网络层进行分片

#### 13. HTTP跟RPC的区别



